🔍 Muhtemel Teknik Sebepler (ve Profesyonel Çözüm Önerileri)
1. ✅ Stream'in Centralize Edilmemesi (Ana Akışın Tek Kaynaktan Yönetilmemesi)
Sorun:
Hem UserCameraView hem de HairAnalysisWidget kendi içinde kamera başlatmaya çalışıyor → MediaStream çakışması + duplicate permission error riski.

Çözüm:
Kamera stream’i sadece bir yerde (örn: avatar-chat-widget.tsx) başlatın ve hem üst hem alt component’lere prop veya React Context ile verin. Örnek Context setup:

tsx
Kopyala
Düzenle
const CameraContext = createContext<{ stream: MediaStream | null }>({ stream: null });
tsx
Kopyala
Düzenle
<CameraContext.Provider value={{ stream: videoStreamRef.current }}>
  <UserCameraView />
  <HairAnalysisWidget />
</CameraContext.Provider>
2. ✅ useEffect Timing Çakışması
Sorun:
HairAnalysisWidget bileşeni mount oluyor ama streamReady hâlâ false. Bu yüzden “Initializing camera…” mesajı takılı kalıyor.

Çözüm:
streamReady değil, videoStreamRef.current’ın null olup olmadığına göre davranmak daha sağlam bir yapı kurar:

tsx
Kopyala
Düzenle
useEffect(() => {
  if (videoRef.current && videoStreamRef.current) {
    videoRef.current.srcObject = videoStreamRef.current;
    videoRef.current.play().catch(console.error);
  }
}, [videoStreamRef.current]); // veya sadece once run
Veya kontrolü şu şekilde yap:

tsx
Kopyala
Düzenle
if (!videoStreamRef.current) return <div>Initializing camera...</div>
return <video ref={videoRef} autoPlay />
3. ✅ Camera Start İşlemini Bir Utility Fonksiyona Çekin
Hair button clicked gibi event’lerde hem setCameraEnabled hem de getUserMedia çağrısı yapıyorsanız, bunları garanti altına alan bir utility fonksiyon kullanın:

tsx
Kopyala
Düzenle
async function ensureCameraReady() {
  if (!videoStreamRef.current) {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      videoStreamRef.current = stream;
      setStreamReady(true);
    } catch (err) {
      console.error("Camera error:", err);
    }
  }
}
4. ✅ videoRef.current.srcObject Hatası
Sorun: