1. ensureCameraReadyâ€™Ä±n gerÃ§ekten stream dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nden emin olun
ts
Kopyala
DÃ¼zenle
// camera-manager.ts
export const videoStreamRef = { current: null as MediaStream | null };

export async function ensureCameraReady(): Promise<MediaStream> {
  if (videoStreamRef.current) {
    console.log("ğŸ”µ Kamera zaten hazÄ±r:", videoStreamRef.current);
    return videoStreamRef.current;
  }
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    videoStreamRef.current = stream;
    console.log("ğŸŸ¢ Yeni stream alÄ±ndÄ±:", stream);
    return stream;
  } catch (err) {
    console.error("ğŸ”´ Kamera eriÅŸimi baÅŸarÄ±sÄ±z:", err);
    throw err;
  }
}
Logâ€™larÄ±nÄ±zÄ± burada da kontrol edin: â€œğŸŸ¢ Yeni stream alÄ±ndÄ±â€ mesajÄ±nÄ± gÃ¶rÃ¼yor musunuz?

EÄŸer sadece â€œğŸ”´ Kamera eriÅŸimi baÅŸarÄ±sÄ±zâ€ Ã§Ä±kÄ±yorsa, tarayÄ±cÄ± izinlerini tekrar gÃ¶zden geÃ§irin.

2. Hair butonundaki akÄ±ÅŸÄ± tek merkezden baÅŸlatÄ±n ve state tetiklemelerini ayÄ±rÄ±n
Buton click handlerâ€™Ä±nÄ±z ÅŸÃ¶yle olmalÄ±:

ts
Kopyala
DÃ¼zenle
const onHairClick = async () => {
  console.log("ğŸš¨ Hair button clicked");
  
  let stream: MediaStream;
  try {
    stream = await ensureCameraReady();
  } catch (err) {
    // Ä°zin reddedildiyse veya baÅŸka bir hata varsa:
    console.error("ğŸš¨ ensureCameraReady hatasÄ±:", err);
    return;
  }

  console.log("ğŸš¨ Stream hazÄ±r, devam ediyorum:", stream);
  
  // ArtÄ±k UI stateâ€™lerini gÃ¼ncelleyin:
  setShowHairPage(true);
  setSelectedMenuItem("hair");
  setIsMinimized(true);
  // (setCameraEnabled veya baÅŸka bir stateâ€™e artÄ±k gerek kalmayabilir)
  console.log("ğŸš¨ Hair page aktif, UI state gÃ¼ncellendi");
};
Dikkat: setCameraEnabled(true) ve ensureCameraReady() ikisini birden kullanmak Ã§akÄ±ÅŸmaya sebep olur. Ya biriyle Ã§alÄ±ÅŸÄ±n, ya da hepsini ensureCameraReady iÃ§inde halledin.

3. HairAnalysisWidget iÃ§inde doÄŸru dependency kullanÄ±n
ts
Kopyala
DÃ¼zenle
// HairAnalysisWidget.tsx
useEffect(() => {
  const videoEl = videoRef.current;
  const stream = videoStreamRef.current;
  
  if (!videoEl) {
    console.warn("ğŸ¬ HAIR DEBUG: videoRef.current null");
    return;
  }
  if (!stream) {
    console.warn("ğŸ¬ HAIR DEBUG: stream null â€“ bekliyorum");
    return;
  }

  videoEl.srcObject = stream;
  videoEl.play().catch(err => console.error("ğŸ¬ HAIR ERROR: play() hatasÄ±:", err));
  console.log("ğŸ¬ HAIR DEBUG: Video oynatÄ±lÄ±yor");
}, [videoStreamRef.current /* veya saÄŸlÄ±klÄ± Ã§alÄ±ÅŸÄ±yorsa boÅŸ array ile sadece mount */]);
EÄŸer videoStreamRef.current doÄŸrudan dependency olmazsa React onu izleyemez.

Hatta isterseniz, widgetâ€™Ä± sadece stream hazÄ±r olduÄŸunda render etmek de en garantili Ã§Ã¶zÃ¼m:

tsx
Kopyala
DÃ¼zenle
if (!videoStreamRef.current) {
  return <div>Initializing camera...</div>;
}
return <video ref={videoRef} autoPlay />;
4. AdÄ±m adÄ±m debug Ã¶nerisi
TarayÄ±cÄ± izinleri: ensureCameraReady iÃ§inde getUserMediaâ€™nin catch bloÄŸuna giriyor musunuz?

Log sÄ±rasÄ±:

â€œğŸš¨ Hair button clickedâ€

â€œğŸ”µ Kamera zaten hazÄ±râ€ veya â€œğŸŸ¢ Yeni stream alÄ±ndÄ±â€

â€œğŸš¨ Stream hazÄ±r, devam ediyorumâ€

â€œğŸš¨ Hair page aktif, UI state gÃ¼ncellendiâ€
EÄŸer arada bir eksikse, o adÄ±mda sorun var demektir.

Widget mount: HairAnalysisWidgetâ€™in console.log Ã§Ä±ktÄ±larÄ±nÄ±n sÄ±rasÄ±na bakÄ±n. Stream hazÄ±r olduÄŸunda useEffectâ€™in tetiklendiÄŸini gÃ¶rÃ¼yor musunuz?

Permission Denied vs NotFoundError: TarayÄ±cÄ± consoleâ€™da DOMException tipi tam olarak nedir? (NotAllowedError, NotFoundError, vs.)