Below is a state-machine–driven architecture for a “dynamic avatar player” that you can implement in Replit (or any web-app framework) to switch between Adana01, Adana02, and Adana03 based on user activity. The core ideas are:

State Machine

Timer & Event Handling

Media‐Player Component

API Integration

Resource Management & Caching

1. State Machine
Use a lightweight JS state‐machine library (e.g. XState) or roll your own.
Define three states:

mermaid
Kopyala
Düzenle
stateDiagram-v2
    [*] --> Idle
    Idle       --> LightRespond   : onQuestion()
    LightRespond --> Idle         : onPlaybackEnd()
    LightRespond --> FullAvatar   : afterQuestionCount>1
    FullAvatar  --> Idle          : onInactivityTimeout()
    FullAvatar  --> LightRespond  : onQuestion()
Idle

Default. Plays Adana01 in loop.

On entry: start inactivity timer (e.g. 3 min).

LightRespond

Plays Adana02 + ElevenLabs voice.

On entry: cancel idle timer, trigger video+audio.

Maintain questionCount; if > 1, transition to FullAvatar.

FullAvatar

Uses HeyGen API. Full avatar.

On entry: call HeyGen API (asynchronously), play resulting stream.

If no questions for X time, revert to Idle.

2. Timer & Event Handling
Inactivity Timer (e.g. 3 minutes):

In Idle, if timer fires ⇒ restart Adana01 loop.

In FullAvatar, if timer fires ⇒ transition to Idle.

Question Event:

User sends a message ⇒ emit onQuestion() event to state machine.

Increment questionCount.

Playback End:

After each Adana02/HeyGen video finishes, emit onPlaybackEnd().

3. Media-Player Component
A single React/Vue/Svelte component that:

jsx
Kopyala
Düzenle
function DynamicPlayer({ state, mediaUrl, onEnded }) {
  return (
    <video
      src={mediaUrl}
      autoPlay
      loop={state === 'Idle'}
      onEnded={() => {
        if (state !== 'Idle') onEnded();
      }}
      muted={false}
      playsInline
      style={{ width: '100%', height: 'auto' }}
    />
  );
}
Props

state: “Idle” | “LightRespond” | “FullAvatar”

mediaUrl: URL to the current video asset

Behavior

loop=true only in Idle.

On non-idle onEnded, call stateMachine.send('onPlaybackEnd').

4. API Integration Layer
ElevenLabs (Audio)
js
Kopyala
Düzenle
async function fetchElevenLabsAudio(text) {
  const resp = await fetch('/api/elevenlabs', {
    method: 'POST', body: JSON.stringify({ text }) });
  const blob = await resp.blob();
  return URL.createObjectURL(blob);
}
Pre-fetch or cache recent responses for speed.

HeyGen (Video + Lip-Sync)
js
Kopyala
Düzenle
async function fetchHeyGenVideo(text) {
  const resp = await fetch('/api/heygen', { method:'POST', body: JSON.stringify({ text }) });
  const data = await resp.json();
  return data.videoUrl; 
}
Kick off on entering FullAvatar; show a “loading…” placeholder if needed.

5. Putting It All Together
js
Kopyala
Düzenle
import { createMachine, interpret } from 'xstate';

const playerMachine = createMachine({
  id: 'player',
  initial: 'Idle',
  context: { questionCount: 0, mediaUrl: '' },
  states: {
    Idle: {
      entry: ['startIdleLoop'],
      exit: ['clearIdleTimer'],
      on: {
        onQuestion: {
          target: 'LightRespond',
          actions: 'incQuestion'
        }
      }
    },
    LightRespond: {
      entry: ['playAdana02', 'clearIdleTimer'],
      on: {
        onPlaybackEnd: [
          {
            cond: ctx => ctx.questionCount > 1,
            target: 'FullAvatar'
          },
          { target: 'Idle' }
        ]
      }
    },
    FullAvatar: {
      entry: ['playHeyGen', 'startIdleTimer'],
      on: {
        onQuestion: 'LightRespond',
        onIdleTimeout: 'Idle'
      }
    }
  }
}, {
  actions: {
    incQuestion: assign({ questionCount: c => c + 1 }),
    startIdleLoop: (ctx, ev) => { ctx.mediaUrl = '/videos/adana01.mp4'; /* loop auto */ },
    playAdana02: async (ctx, ev) => {
      const audioUrl = await fetchElevenLabsAudio(ev.text);
      ctx.mediaUrl = '/videos/adana02.mp4';
      // synchronize play: video + audio
      syncPlay(ctx.mediaUrl, audioUrl);
    },
    playHeyGen: async (ctx, ev) => {
      const videoUrl = await fetchHeyGenVideo(latestUserText());
      ctx.mediaUrl = videoUrl;
    },
    startIdleTimer: (ctx, ev) => { ctx.idleTimer = setTimeout(() => service.send('onIdleTimeout'), 3*60*1000); },
    clearIdleTimer: (ctx, ev) => { clearTimeout(ctx.idleTimer); }
  }
});

const service = interpret(playerMachine).start();
syncPlay(videoUrl, audioUrl): load both, start them at the same time via JS MediaElement.

Deployment on Replit
Code Structure

/public/videos/ → host Adana01.mp4 & Adana02.mp4

/src/components/DynamicPlayer.jsx → the React component

/src/machines/playerMachine.js → XState definition

/api/elevenlabs.js & /api/heygen.js → serverless endpoints

Dev Loop

Edit in Replit

Hot-reload front end

Test transitions manually:

Wait 3 min → Idle loop

Ask question → Adana02 + audio

Ask second question → HeyGen

Optimization

Pre-warm HeyGen requests for repeated prompts

Cache ElevenLabs audio for identical text

CDN serve static assets

This architecture cleanly separates concerns, minimizes HeyGen API calls (only after the second question), and keeps the front end in sync via a single state machine and player component. You can adapt the timers, thresholds, and transitions to your exact UX requirements.