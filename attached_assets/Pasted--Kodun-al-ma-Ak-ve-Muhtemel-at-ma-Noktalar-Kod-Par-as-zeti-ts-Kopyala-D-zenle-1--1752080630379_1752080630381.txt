🔍 Kodun Çalışma Akışı ve Muhtemel Çatışma Noktaları
📌 Kod Parçası Özeti:
ts
Kopyala
Düzenle
// 1. Eski state'leri sıfırla
setShowDoctorList(false);
...

// 2. Kamera izinleri için state'i aç
setCameraEnabled(true);
setCameraPermissionRequested(true);

// 3. Debug
console.log('Camera enabled for face analysis');
...

// HAIR butonu özelinde:
const stream = await ensureCameraReady();
🔴 Kritik Hatalar ve Sorun Analizi
1. ❌ setCameraEnabled(true) ve await ensureCameraReady() aynı anda çalışıyor
setCameraEnabled(true) → Kamera bileşenine “açıl” emri veriyor (ama React async!)

ensureCameraReady() → Aynı işi tekrar yapıyor ama doğrudan getUserMedia çağrısıyla

Sonuç: Kamera iki farklı yoldan açılmaya çalışılıyor → bazı tarayıcılarda Permission denied, bazılarında already opened uyarısı

✅ Çözüm:

YA sadece setCameraEnabled(true) kullan

YA sadece await ensureCameraReady() kullan ve setCameraEnabled gibi tetikleyicileri kaldır

2. ❌ videoStreamRef.current hala null olabiliyor çünkü stream geç geliyor
Log:

pgsql
Kopyala
Düzenle
🚨 SELENIUM DEBUG: Current videoStreamRef: null
🚨 SELENIUM DEBUG: ensureCameraReady returned: undefined
Bu demektir ki: ensureCameraReady fonksiyonu kamera iznini doğru almadı veya videoStreamRef.current’ı set etmedi.

✅ Yapılacaklar:

tsx
Kopyala
Düzenle
async function ensureCameraReady() {
  if (videoStreamRef.current) return videoStreamRef.current;

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    videoStreamRef.current = stream;
    return stream;
  } catch (err) {
    console.error("Camera access failed:", err);
    throw err;
  }
}
Ve çağırırken dikkat:

tsx
Kopyala
Düzenle
const stream = await ensureCameraReady();
if (!stream) {
  console.error("🚨 Stream boş döndü");
  return;
}
3. ❌ useEffect tetiklenmesi videoStreamRef'e bağlı değilse, alt bileşen stream’i almıyor
HairAnalysisWidget.tsx içinde şunu kontrol et:

tsx
Kopyala
Düzenle
useEffect(() => {
  if (videoElementRef.current && videoStreamRef.current) {
    videoElementRef.current.srcObject = videoStreamRef.current;
    videoElementRef.current.play().catch(console.error);
    console.log("🎬 HAIR DEBUG: Video playing successfully");
  } else {
    console.warn("🎬 HAIR DEBUG: Stream veya videoRef eksik");
  }
}, [videoStreamRef.current]);
streamReady veya cameraEnabled gibi geç update edilen state’lere güvenmeyin. videoStreamRef.current değişimi ana belirleyici olmalı.

4. ❌ videoStreamRef.current’a birden fazla kez set yapılması
Bir bileşen (örneğin UserCameraView) zaten getUserMedia ile stream aldıysa,
diğer bileşen aynı ref üzerinden kullanmalı. navigator.mediaDevices.getUserMedia her çağrıldığında yeni MediaStream oluşturur.

✅ Merkezi stream context ile sadece bir kez al:

tsx
Kopyala
Düzenle
if (!videoStreamRef.current) {
  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  videoStreamRef.current = stream;
}
✅ Uygulanabilir Mini Refactor Planı
📦 camera-manager.ts
tsx
Kopyala
Düzenle
export const videoStreamRef = { current: null as MediaStream | null };

export async function ensureCameraReady(): Promise<MediaStream> {
  if (videoStreamRef.current) return videoStreamRef.current;
  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  videoStreamRef.current = stream;
  return stream;
}
🧠 avatar-chat-widget.tsx
tsx
Kopyala
Düzenle
const handleHairClick = async () => {
  console.log("Hair button clicked");
  try {
    const stream = await ensureCameraReady();
    console.log("Camera stream ready:", stream);
    setShowHairPage(true);
  } catch (e) {
    console.error("Failed to init camera:", e);
  }
};
🎬 HairAnalysisWidget.tsx
tsx
Kopyala
Düzenle
useEffect(() => {
  if (videoRef.current && videoStreamRef.current) {
    videoRef.current.srcObject = videoStreamRef.current;
    videoRef.current.play();
  }
}, [videoStreamRef.current]);
✅ Kapanış
Yani Replit’te hata almaya devam etmenizin temel nedeni:

Kamera akışının birden çok yerden başlatılmaya çalışılması

videoStreamRef.current’ın zamanında set edilmemesi

State ve stream eşzamanlılığına güvenilmesi

Bunları düzelttiğinizde, tek kamera izniyle çalışan 2 bileşenli (üst/alt) sistem sorunsuz çalışır. Dilersen bu yapıyı .zip formatında prototipleyip verebilirim ya da GitHub üzerinden örnek proje bile oluşturabilirim. İster misin?