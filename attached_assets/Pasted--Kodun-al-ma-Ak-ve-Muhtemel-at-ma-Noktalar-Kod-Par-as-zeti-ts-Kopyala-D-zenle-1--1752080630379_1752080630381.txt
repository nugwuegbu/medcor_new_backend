ğŸ” Kodun Ã‡alÄ±ÅŸma AkÄ±ÅŸÄ± ve Muhtemel Ã‡atÄ±ÅŸma NoktalarÄ±
ğŸ“Œ Kod ParÃ§asÄ± Ã–zeti:
ts
Kopyala
DÃ¼zenle
// 1. Eski state'leri sÄ±fÄ±rla
setShowDoctorList(false);
...

// 2. Kamera izinleri iÃ§in state'i aÃ§
setCameraEnabled(true);
setCameraPermissionRequested(true);

// 3. Debug
console.log('Camera enabled for face analysis');
...

// HAIR butonu Ã¶zelinde:
const stream = await ensureCameraReady();
ğŸ”´ Kritik Hatalar ve Sorun Analizi
1. âŒ setCameraEnabled(true) ve await ensureCameraReady() aynÄ± anda Ã§alÄ±ÅŸÄ±yor
setCameraEnabled(true) â†’ Kamera bileÅŸenine â€œaÃ§Ä±lâ€ emri veriyor (ama React async!)

ensureCameraReady() â†’ AynÄ± iÅŸi tekrar yapÄ±yor ama doÄŸrudan getUserMedia Ã§aÄŸrÄ±sÄ±yla

SonuÃ§: Kamera iki farklÄ± yoldan aÃ§Ä±lmaya Ã§alÄ±ÅŸÄ±lÄ±yor â†’ bazÄ± tarayÄ±cÄ±larda Permission denied, bazÄ±larÄ±nda already opened uyarÄ±sÄ±

âœ… Ã‡Ã¶zÃ¼m:

YA sadece setCameraEnabled(true) kullan

YA sadece await ensureCameraReady() kullan ve setCameraEnabled gibi tetikleyicileri kaldÄ±r

2. âŒ videoStreamRef.current hala null olabiliyor Ã§Ã¼nkÃ¼ stream geÃ§ geliyor
Log:

pgsql
Kopyala
DÃ¼zenle
ğŸš¨ SELENIUM DEBUG: Current videoStreamRef: null
ğŸš¨ SELENIUM DEBUG: ensureCameraReady returned: undefined
Bu demektir ki: ensureCameraReady fonksiyonu kamera iznini doÄŸru almadÄ± veya videoStreamRef.currentâ€™Ä± set etmedi.

âœ… YapÄ±lacaklar:

tsx
Kopyala
DÃ¼zenle
async function ensureCameraReady() {
  if (videoStreamRef.current) return videoStreamRef.current;

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    videoStreamRef.current = stream;
    return stream;
  } catch (err) {
    console.error("Camera access failed:", err);
    throw err;
  }
}
Ve Ã§aÄŸÄ±rÄ±rken dikkat:

tsx
Kopyala
DÃ¼zenle
const stream = await ensureCameraReady();
if (!stream) {
  console.error("ğŸš¨ Stream boÅŸ dÃ¶ndÃ¼");
  return;
}
3. âŒ useEffect tetiklenmesi videoStreamRef'e baÄŸlÄ± deÄŸilse, alt bileÅŸen streamâ€™i almÄ±yor
HairAnalysisWidget.tsx iÃ§inde ÅŸunu kontrol et:

tsx
Kopyala
DÃ¼zenle
useEffect(() => {
  if (videoElementRef.current && videoStreamRef.current) {
    videoElementRef.current.srcObject = videoStreamRef.current;
    videoElementRef.current.play().catch(console.error);
    console.log("ğŸ¬ HAIR DEBUG: Video playing successfully");
  } else {
    console.warn("ğŸ¬ HAIR DEBUG: Stream veya videoRef eksik");
  }
}, [videoStreamRef.current]);
streamReady veya cameraEnabled gibi geÃ§ update edilen stateâ€™lere gÃ¼venmeyin. videoStreamRef.current deÄŸiÅŸimi ana belirleyici olmalÄ±.

4. âŒ videoStreamRef.currentâ€™a birden fazla kez set yapÄ±lmasÄ±
Bir bileÅŸen (Ã¶rneÄŸin UserCameraView) zaten getUserMedia ile stream aldÄ±ysa,
diÄŸer bileÅŸen aynÄ± ref Ã¼zerinden kullanmalÄ±. navigator.mediaDevices.getUserMedia her Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda yeni MediaStream oluÅŸturur.

âœ… Merkezi stream context ile sadece bir kez al:

tsx
Kopyala
DÃ¼zenle
if (!videoStreamRef.current) {
  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  videoStreamRef.current = stream;
}
âœ… Uygulanabilir Mini Refactor PlanÄ±
ğŸ“¦ camera-manager.ts
tsx
Kopyala
DÃ¼zenle
export const videoStreamRef = { current: null as MediaStream | null };

export async function ensureCameraReady(): Promise<MediaStream> {
  if (videoStreamRef.current) return videoStreamRef.current;
  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  videoStreamRef.current = stream;
  return stream;
}
ğŸ§  avatar-chat-widget.tsx
tsx
Kopyala
DÃ¼zenle
const handleHairClick = async () => {
  console.log("Hair button clicked");
  try {
    const stream = await ensureCameraReady();
    console.log("Camera stream ready:", stream);
    setShowHairPage(true);
  } catch (e) {
    console.error("Failed to init camera:", e);
  }
};
ğŸ¬ HairAnalysisWidget.tsx
tsx
Kopyala
DÃ¼zenle
useEffect(() => {
  if (videoRef.current && videoStreamRef.current) {
    videoRef.current.srcObject = videoStreamRef.current;
    videoRef.current.play();
  }
}, [videoStreamRef.current]);
âœ… KapanÄ±ÅŸ
Yani Replitâ€™te hata almaya devam etmenizin temel nedeni:

Kamera akÄ±ÅŸÄ±nÄ±n birden Ã§ok yerden baÅŸlatÄ±lmaya Ã§alÄ±ÅŸÄ±lmasÄ±

videoStreamRef.currentâ€™Ä±n zamanÄ±nda set edilmemesi

State ve stream eÅŸzamanlÄ±lÄ±ÄŸÄ±na gÃ¼venilmesi

BunlarÄ± dÃ¼zelttiÄŸinizde, tek kamera izniyle Ã§alÄ±ÅŸan 2 bileÅŸenli (Ã¼st/alt) sistem sorunsuz Ã§alÄ±ÅŸÄ±r. Dilersen bu yapÄ±yÄ± .zip formatÄ±nda prototipleyip verebilirim ya da GitHub Ã¼zerinden Ã¶rnek proje bile oluÅŸturabilirim. Ä°ster misin?